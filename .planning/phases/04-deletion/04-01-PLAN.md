---
phase: 04-deletion
plan: "01"
type: tdd
wave: 1
depends_on: []
files_modified:
  - gmail_cleanup/cleaner.py
  - tests/test_cleaner.py
autonomous: true
requirements:
  - DEL-01
  - DEL-02
  - DEL-03

must_haves:
  truths:
    - "batch_delete() splits IDs into 500-ID chunks and calls batchDelete once per chunk"
    - "batch_delete() retries on 429, 500, 502, 503, 504 with exponential backoff (max 32s)"
    - "batch_delete() raises immediately on 400, 401, 403 without retry"
    - "batch_delete() shows a Rich progress bar tracking chunks processed vs total chunks"
    - "batch_delete() returns the count of successfully deleted emails as an int"
  artifacts:
    - path: "gmail_cleanup/cleaner.py"
      provides: "batch_delete(service, message_ids) implementation"
      exports: ["batch_delete"]
    - path: "tests/test_cleaner.py"
      provides: "Unit tests for batch_delete with mocked service"
  key_links:
    - from: "gmail_cleanup/cleaner.py"
      to: "service.users().messages().batchDelete"
      via: "chunked API call in loop"
      pattern: "batchDelete.*ids.*chunk"
    - from: "gmail_cleanup/cleaner.py"
      to: "HttpError.resp.status"
      via: "int(exc.resp.status) cast for retry decision"
      pattern: "int\\(exc\\.resp\\.status\\)"
---

<objective>
Implement batch_delete() in cleaner.py using TDD: chunked batchDelete calls with exponential backoff retry and Rich progress bar.

Purpose: Core deletion engine. Phase 4 cannot function without this — it permanently removes matched emails in bulk without re-fetching IDs.
Output: Working batch_delete() with full test coverage, ready for main.py to call.
</objective>

<execution_context>
@/Users/dalwrigh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dalwrigh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@gmail_cleanup/cleaner.py
@gmail_cleanup/gmail_client.py
</context>

<feature>
  <name>batch_delete with chunked batchDelete, retry, and progress</name>
  <files>gmail_cleanup/cleaner.py, tests/test_cleaner.py</files>
  <behavior>
    batch_delete(service, message_ids: list[str]) -> int

    Behavior contract:
    - Splits message_ids into chunks of 500 (DEL-01)
    - For each chunk: calls service.users().messages().batchDelete(userId="me", body={"ids": chunk}).execute()
    - batchDelete returns None on success — do NOT inspect return value
    - Shows Rich progress bar via rich.progress.track(chunks, description="Deleting...") (DEL-03)
    - On HttpError: cast int(exc.resp.status) — resp.status is a STRING from httplib2, MUST cast
    - Retry set: {429, 500, 502, 503, 504} — sleep then retry with exponential backoff
    - Backoff: start delay=1, delay = min(delay * 2, 32) — max sleep 32s
    - Sleep AFTER failure, NOT before first attempt
    - Raise immediately on {400, 401, 403} — do not retry
    - Returns total count of emails deleted (len(message_ids) on full success)
    - Empty list input: returns 0 immediately without API calls

    Test cases (all use MagicMock service):
    - Empty list → returns 0, batchDelete not called
    - 501 IDs → batchDelete called twice (chunk of 500 + chunk of 1)
    - Success path → returns len(message_ids)
    - First call raises HttpError(429), second succeeds → returns count (retried)
    - HttpError(403) → raises immediately (no retry, no sleep)
    - HttpError(500) raised twice then succeeds → retried twice, returns count
  </behavior>
  <implementation>
    Replace the NotImplementedError stub in cleaner.py with:

    ```python
    import time
    from googleapiclient.errors import HttpError
    from rich.progress import track


    def batch_delete(service, message_ids: list[str]) -> int:
        """Permanently delete messages in 500-ID chunks. Returns count deleted."""
        if not message_ids:
            return 0

        chunks = [message_ids[i:i + 500] for i in range(0, len(message_ids), 500)]
        deleted = 0

        for chunk in track(chunks, description="Deleting..."):
            delay = 1
            while True:
                try:
                    service.users().messages().batchDelete(
                        userId="me", body={"ids": chunk}
                    ).execute()
                    deleted += len(chunk)
                    break
                except HttpError as exc:
                    status = int(exc.resp.status)
                    if status in {429, 500, 502, 503, 504}:
                        time.sleep(delay)
                        delay = min(delay * 2, 32)
                    else:
                        raise

        return deleted
    ```

    No new dependencies — time, HttpError, and rich.progress.track are all available.
    Import HttpError directly in cleaner.py (not from gmail_client re-export — cleaner.py
    is not a "caller" in the Phase 3 sense; direct import is cleaner here).
  </implementation>
</feature>

<tasks>

<task type="tdd">
  <name>RED: Write failing tests for batch_delete</name>
  <files>tests/test_cleaner.py</files>
  <action>
    Create tests/test_cleaner.py. Import batch_delete from gmail_cleanup.cleaner.
    Write tests using unittest.mock.MagicMock for the service object.

    Required test cases:
    1. test_empty_list: batch_delete(mock_service, []) returns 0; batchDelete never called
    2. test_chunking: 501 IDs causes batchDelete to be called exactly twice (500 + 1 split)
    3. test_success_returns_count: 3 IDs, success → returns 3
    4. test_retry_on_429: first call raises HttpError with status "429", second succeeds → returns count; mock time.sleep to verify it was called once
    5. test_no_retry_on_403: HttpError with status "403" → raises immediately; batchDelete called once; sleep not called
    6. test_retry_twice_then_success: HttpError("500") twice, then success → returns count; sleep called twice

    How to build a fake HttpError:
    ```python
    from unittest.mock import MagicMock, patch
    from googleapiclient.errors import HttpError

    def make_http_error(status: int) -> HttpError:
        resp = MagicMock()
        resp.status = str(status)  # httplib2 returns string
        return HttpError(resp=resp, content=b"error")
    ```

    Run: `uv run pytest tests/test_cleaner.py -v`
    Expected: ALL FAIL (NotImplementedError or ImportError) — this is RED.
    Commit: `test(04-01): add failing tests for batch_delete`
  </action>
  <verify>uv run pytest tests/test_cleaner.py -v 2>&1 | grep -E "FAILED|ERROR|passed"</verify>
  <done>All tests fail — RED phase confirmed. No tests pass yet.</done>
</task>

<task type="tdd">
  <name>GREEN: Implement batch_delete to pass all tests</name>
  <files>gmail_cleanup/cleaner.py</files>
  <action>
    Replace the NotImplementedError stub with the full implementation shown in the
    &lt;implementation&gt; section above.

    Key constraints to implement correctly:
    - Chunk size EXACTLY 500 (DEL-01 requires 500 IDs per API call)
    - int(exc.resp.status) cast — resp.status is a string, casting is MANDATORY
    - Retry set: {429, 500, 502, 503, 504} only
    - Raise immediately on anything else (including 400, 401, 403)
    - Sleep AFTER failure, before retry — NOT before the first attempt
    - track() wraps the chunks list for Rich progress (DEL-03)
    - batchDelete returns None — do not inspect return value
    - deleted += len(chunk) after each successful chunk call

    Run: `uv run pytest tests/test_cleaner.py -v`
    Expected: ALL PASS — GREEN phase confirmed.
    Commit: `feat(04-01): implement batch_delete with chunked batchDelete, retry, and progress`
  </action>
  <verify>uv run pytest tests/test_cleaner.py -v 2>&1 | grep -E "passed|FAILED|ERROR"</verify>
  <done>All 6 tests pass. No failures. GREEN phase confirmed.</done>
</task>

</tasks>

<verification>
- uv run pytest tests/test_cleaner.py -v — all 6 tests pass
- uv run pytest tests/ -v — no regressions in test_date_utils.py or test_gmail_client.py
- batch_delete imported cleanly: uv run python -c "from gmail_cleanup.cleaner import batch_delete; print('OK')"
</verification>

<success_criteria>
- batch_delete(service, []) returns 0 without API calls
- 501 IDs causes exactly 2 batchDelete API calls
- 429/5xx triggers retry with sleep; 403 raises immediately
- All 6 unit tests pass; full test suite has no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-deletion/04-01-SUMMARY.md`
</output>
