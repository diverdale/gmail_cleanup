---
phase: 02-cli-and-dry-run
plan: "01"
type: tdd
wave: 1
depends_on: []
files_modified:
  - gmail_cleanup/date_utils.py
  - tests/__init__.py
  - tests/test_date_utils.py
autonomous: true
requirements:
  - CLI-01
  - CLI-02

must_haves:
  truths:
    - "months_ago_to_cutoff(6) returns a UTC-aware datetime ~6 months in the past"
    - "parse_date_to_cutoff('2024-01-01') returns a UTC-aware datetime at midnight 2024-01-01"
    - "build_gmail_query(cutoff) returns a Gmail query string in 'before:YYYY/MM/DD' format"
    - "Passing an invalid date string to parse_date_to_cutoff raises ValueError"
  artifacts:
    - path: "gmail_cleanup/date_utils.py"
      provides: "Date arithmetic and Gmail query building"
      contains: "def months_ago_to_cutoff"
    - path: "tests/test_date_utils.py"
      provides: "Regression tests for all date utility functions"
      contains: "def test_months_ago_to_cutoff"
  key_links:
    - from: "gmail_cleanup/date_utils.py"
      to: "gmail_cleanup/gmail_client.py"
      via: "build_gmail_query() output passed as query argument to count_messages()"
      pattern: "build_gmail_query"
    - from: "gmail_cleanup/date_utils.py"
      to: "gmail_cleanup/main.py"
      via: "months_ago_to_cutoff and parse_date_to_cutoff called from main() to produce cutoff datetime"
      pattern: "from gmail_cleanup.date_utils import"
---

<objective>
Implement and test date utility functions that translate CLI arguments into Gmail-compatible query strings.

Purpose: main.py needs well-tested helpers that convert --older-than N and --before YYYY-MM-DD into a Gmail search query. Getting date arithmetic wrong silently (timezone, off-by-one) would cause the tool to delete the wrong emails — this is why TDD is warranted here.
Output: gmail_cleanup/date_utils.py with three pure functions; tests/test_date_utils.py with full coverage.
</objective>

<execution_context>
@/Users/dalwrigh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dalwrigh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@gmail_cleanup/auth.py
@gmail_cleanup/main.py
</context>

<feature>
  <name>Date utilities: cutoff calculation and Gmail query building</name>
  <files>gmail_cleanup/date_utils.py, tests/__init__.py, tests/test_date_utils.py</files>

  <behavior>
    Three pure functions with well-defined I/O:

    1. months_ago_to_cutoff(months: int) -> datetime
       - Returns UTC-aware datetime exactly N months before now (using relativedelta, not timedelta)
       - Input: 6 -> Output: datetime(now - 6 months, tzinfo=timezone.utc)
       - Input: 0 -> Output: datetime(now, tzinfo=timezone.utc) [edge case]
       - Input: 1 -> Output: datetime(now - 1 month, tzinfo=timezone.utc)

    2. parse_date_to_cutoff(date_str: str) -> datetime
       - Parses YYYY-MM-DD string, returns UTC-aware datetime at midnight
       - Input: "2024-01-01" -> Output: datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)
       - Input: "2024-06-15" -> Output: datetime(2024, 6, 15, 0, 0, 0, tzinfo=timezone.utc)
       - Input: "not-a-date" -> Raises ValueError
       - Input: "2024-13-01" -> Raises ValueError (invalid month)

    3. build_gmail_query(cutoff: datetime) -> str
       - Converts a datetime cutoff to a Gmail search query string
       - Gmail uses "before:YYYY/MM/DD" format (slash-separated, not hyphen)
       - Input: datetime(2024, 1, 1) -> Output: "before:2024/01/01"
       - Input: datetime(2023, 6, 15) -> Output: "before:2023/06/15"

    NOTE: Phase 3 will replace build_gmail_query with epoch-timestamp format for timezone precision.
    Phase 2 uses the simpler "before:YYYY/MM/DD" format which is correct for now.
  </behavior>

  <implementation>
    Create gmail_cleanup/date_utils.py:

    ```python
    """Date arithmetic and Gmail query helpers for CLI argument processing."""

    from datetime import datetime, timezone

    from dateutil.relativedelta import relativedelta


    def months_ago_to_cutoff(months: int) -> datetime:
        """Return UTC-aware datetime exactly N calendar months before now.

        Uses relativedelta (not timedelta) for correct month arithmetic.
        For example, 1 month before 2024-03-31 is 2024-02-29 (not 2024-03-03).
        """
        return datetime.now(timezone.utc) - relativedelta(months=months)


    def parse_date_to_cutoff(date_str: str) -> datetime:
        """Parse a YYYY-MM-DD string into a UTC-aware datetime at midnight.

        Raises ValueError if the string is not a valid YYYY-MM-DD date.
        Phase 3 will refine the cutoff to epoch timestamp for timezone precision.
        """
        return datetime.strptime(date_str, "%Y-%m-%d").replace(tzinfo=timezone.utc)


    def build_gmail_query(cutoff: datetime) -> str:
        """Convert a cutoff datetime into a Gmail search query string.

        Uses 'before:YYYY/MM/DD' format (slash-separated per Gmail API spec).
        Phase 3 will replace this with epoch timestamp format for timezone precision.
        """
        return f"before:{cutoff.strftime('%Y/%m/%d')}"
    ```

    Create tests/__init__.py (empty file to make tests a package).

    Create tests/test_date_utils.py:
    - Import freeze_time or use datetime mocking via unittest.mock.patch to make months_ago_to_cutoff deterministic.
    - Actually: for months_ago_to_cutoff, test structural properties (result is UTC-aware, result is in the past, result has correct month offset) rather than exact datetime matching, to avoid flaky time-dependency.
    - For parse_date_to_cutoff, test exact outputs (deterministic from input string).
    - For build_gmail_query, test exact output format.

    Use pytest (add to pyproject.toml dev dependencies if not present, or run directly with `uv run pytest`).

    Test file structure:
    ```python
    """Tests for gmail_cleanup.date_utils."""
    from datetime import datetime, timezone

    import pytest
    from dateutil.relativedelta import relativedelta

    from gmail_cleanup.date_utils import (
        build_gmail_query,
        months_ago_to_cutoff,
        parse_date_to_cutoff,
    )


    class TestMonthsAgeToCutoff:
        def test_returns_utc_aware_datetime(self):
            result = months_ago_to_cutoff(6)
            assert result.tzinfo is not None
            assert result.tzinfo == timezone.utc

        def test_result_is_in_the_past(self):
            result = months_ago_to_cutoff(1)
            assert result < datetime.now(timezone.utc)

        def test_6_months_ago_has_correct_month_offset(self):
            now = datetime.now(timezone.utc)
            result = months_ago_to_cutoff(6)
            expected = now - relativedelta(months=6)
            # Allow 5-second window for test execution time
            assert abs((result - expected).total_seconds()) < 5

        def test_zero_months_returns_approximately_now(self):
            now = datetime.now(timezone.utc)
            result = months_ago_to_cutoff(0)
            assert abs((result - now).total_seconds()) < 5


    class TestParseDateToCutoff:
        def test_valid_date_returns_utc_midnight(self):
            result = parse_date_to_cutoff("2024-01-01")
            assert result == datetime(2024, 1, 1, 0, 0, 0, tzinfo=timezone.utc)

        def test_mid_year_date(self):
            result = parse_date_to_cutoff("2024-06-15")
            assert result == datetime(2024, 6, 15, 0, 0, 0, tzinfo=timezone.utc)

        def test_invalid_format_raises_value_error(self):
            with pytest.raises(ValueError):
                parse_date_to_cutoff("not-a-date")

        def test_invalid_month_raises_value_error(self):
            with pytest.raises(ValueError):
                parse_date_to_cutoff("2024-13-01")

        def test_wrong_format_raises_value_error(self):
            with pytest.raises(ValueError):
                parse_date_to_cutoff("01/01/2024")


    class TestBuildGmailQuery:
        def test_formats_with_slashes_not_hyphens(self):
            cutoff = datetime(2024, 1, 1, tzinfo=timezone.utc)
            result = build_gmail_query(cutoff)
            assert result == "before:2024/01/01"

        def test_zero_pads_month_and_day(self):
            cutoff = datetime(2023, 6, 5, tzinfo=timezone.utc)
            result = build_gmail_query(cutoff)
            assert result == "before:2023/06/05"

        def test_prefix_is_before(self):
            cutoff = datetime(2020, 12, 31, tzinfo=timezone.utc)
            result = build_gmail_query(cutoff)
            assert result.startswith("before:")
    ```
  </implementation>
</feature>

<verification>
RED-GREEN-REFACTOR cycle:

RED:
```bash
cd /Users/dalwrigh/dev/gmail_cleanup
uv run pytest tests/test_date_utils.py -v
# Must fail (ModuleNotFoundError — date_utils.py does not exist yet)
```

GREEN (after creating date_utils.py):
```bash
uv run pytest tests/test_date_utils.py -v
# Must pass — all tests green
```

REFACTOR (if needed):
```bash
uv run pytest tests/test_date_utils.py -v
# Must still pass after any cleanup
```
</verification>

<success_criteria>
- tests/test_date_utils.py exists with at least 10 test cases covering all three functions
- gmail_cleanup/date_utils.py implements months_ago_to_cutoff, parse_date_to_cutoff, build_gmail_query
- All tests pass: `uv run pytest tests/test_date_utils.py -v` exits 0
- parse_date_to_cutoff raises ValueError for invalid input (not crash, not silent)
- build_gmail_query output uses slash separators: "before:YYYY/MM/DD"
- All datetimes are UTC-aware (tzinfo=timezone.utc set, not naive)
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-and-dry-run/02-01-SUMMARY.md`
</output>
