---
phase: 03-message-discovery
plan: "02"
type: tdd
wave: 1
depends_on: []
files_modified:
  - gmail_cleanup/gmail_client.py
  - tests/test_gmail_client.py
autonomous: true
requirements:
  - DISC-01

must_haves:
  truths:
    - "list_message_ids() fetches all pages until nextPageToken is absent — no silent truncation"
    - "list_message_ids() yields every message ID from every page as a flat list"
    - "If an API error occurs mid-pagination, list_message_ids() raises HttpError (no partial result)"
    - "count_messages() is removed — callers use len(list_message_ids(...))"
    - "Pagination tests use a mocked service — no real Gmail API calls"
  artifacts:
    - path: "gmail_cleanup/gmail_client.py"
      provides: "Full-pagination message ID fetching via nextPageToken loop"
      contains: "list_message_ids"
    - path: "tests/test_gmail_client.py"
      provides: "Pagination test suite with mocked Gmail API service"
      contains: "nextPageToken"
  key_links:
    - from: "tests/test_gmail_client.py"
      to: "gmail_cleanup/gmail_client.py"
      via: "import list_message_ids"
      pattern: "from gmail_cleanup.gmail_client import"
    - from: "gmail_cleanup/gmail_client.py"
      to: "Gmail API list endpoint"
      via: "service.users().messages().list() with pageToken"
      pattern: "pageToken"
---

<objective>
Replace the approximate count_messages() with a fully-paginated list_message_ids() function.

Purpose: Phase 2's count_messages() stops at 500 results — a mailbox with 2,000 matching emails would silently show ~500. list_message_ids() loops through all pages using nextPageToken until exhausted, returning every matching message ID. Callers use len() to get the exact count.

Output: Updated `gmail_client.py` with list_message_ids(); new `tests/test_gmail_client.py` covering pagination, empty results, and mid-pagination errors.
</objective>

<execution_context>
@/Users/dalwrigh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dalwrigh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@gmail_cleanup/gmail_client.py
</context>

<feature>
  <name>Paginated message ID fetching with nextPageToken loop</name>
  <files>gmail_cleanup/gmail_client.py, tests/test_gmail_client.py</files>
  <behavior>
    list_message_ids(service, query: str) -> list[str]
    - Makes repeated calls to service.users().messages().list() with maxResults=500
    - First call: list(userId="me", q=query, maxResults=500)
    - Subsequent calls: add pageToken=result["nextPageToken"]
    - Each response: extend result list with [m["id"] for m in result.get("messages", [])]
    - Loop ends when "nextPageToken" is absent from response
    - Returns flat list of all message ID strings
    - If HttpError raised during any page fetch: propagate it (do not catch)
    - Cases:
      service returns 1 page of 3 messages, no nextPageToken -> returns list of 3 IDs
      service returns 2 pages (500 + 200 messages) -> returns list of 700 IDs
      service returns empty result (no "messages" key, no nextPageToken) -> returns []
      service raises HttpError on page 2 of 3 -> HttpError propagates to caller
      service returns page with no "messages" key but has nextPageToken -> handles gracefully (extends with [])

    count_messages(service, query) is REMOVED entirely — do not keep it, do not stub it.
    list_messages() stub is ALSO REMOVED — replace entire file.
  </behavior>
  <implementation>
    RED phase: Create tests/test_gmail_client.py with failing tests.

    Use unittest.mock.MagicMock to simulate the Gmail API service chain:
    service.users().messages().list().execute() pattern.

    Build a helper that creates a mock service returning a sequence of pages:
    ```python
    def make_mock_service(pages):
        # pages: list of dicts, each like {"messages": [...], "nextPageToken": "tok"} or {"messages": [...]}
        mock_service = MagicMock()
        execute_mock = MagicMock(side_effect=[page for page in pages])
        mock_service.users.return_value.messages.return_value.list.return_value.execute = execute_mock
        return mock_service
    ```

    Tests to write:
    - test_single_page_returns_all_ids: 1 page, 3 messages -> list of 3 IDs
    - test_two_pages_returns_all_ids: page1 has nextPageToken, page2 does not -> combined list
    - test_empty_result_returns_empty_list: response has no "messages" key, no nextPageToken -> []
    - test_last_page_has_no_messages_key: page1 has messages+nextPageToken, page2 has no "messages" key -> IDs from page1 only
    - test_http_error_propagates: service raises HttpError on execute() -> HttpError raised from list_message_ids
    - test_pagetoken_passed_on_second_call: verify list() called with pageToken= argument on second call
    - test_maxresults_is_500: verify list() called with maxResults=500

    Run tests — MUST fail at RED (commit as RED).

    GREEN phase: Rewrite gmail_cleanup/gmail_client.py:

    ```python
    """Gmail API operations — message discovery in Phase 3, deletion in Phase 4."""

    from googleapiclient.errors import HttpError  # noqa: F401 — re-exported for callers


    def list_message_ids(service, query: str) -> list[str]:
        """Return all message IDs matching query via paginated API calls.

        Uses nextPageToken loop with maxResults=500 per page. Returns every
        matching message ID — no silent truncation. Raises HttpError on API failure.
        """
        ids: list[str] = []
        page_token = None
        while True:
            kwargs: dict = {"userId": "me", "q": query, "maxResults": 500}
            if page_token:
                kwargs["pageToken"] = page_token
            result = service.users().messages().list(**kwargs).execute()
            ids.extend(m["id"] for m in result.get("messages", []))
            page_token = result.get("nextPageToken")
            if not page_token:
                break
        return ids
    ```

    Run tests — MUST pass at GREEN (commit as GREEN).

    REFACTOR: Docstring clarity only. Run tests again (commit as REFACTOR only if changes made).

    NOTE: HttpError import kept with noqa comment — Phase 4 callers (main.py, cleaner.py) import it from here.
  </implementation>
</feature>

<verification>
After GREEN phase:
- `uv run pytest tests/test_gmail_client.py -v` passes all tests
- `python -c "from gmail_cleanup.gmail_client import list_message_ids; print('OK')"` prints OK
- `python -c "from gmail_cleanup.gmail_client import count_messages"` raises ImportError (count_messages removed)
- `uv run pytest tests/ -v` — all tests pass (date_utils tests may still fail if 03-01 not run yet; check gmail_client tests only)
</verification>

<success_criteria>
- All tests in tests/test_gmail_client.py pass
- list_message_ids() imported successfully from gmail_cleanup.gmail_client
- count_messages does NOT exist in gmail_client.py
- Pagination loop correctly passes pageToken on subsequent calls (verified by mock assertion)
- Empty response (no "messages" key) returns [] without error
</success_criteria>

<output>
After completion, create `.planning/phases/03-message-discovery/03-02-SUMMARY.md`
</output>
