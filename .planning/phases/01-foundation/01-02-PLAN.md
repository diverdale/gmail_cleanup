---
phase: 01-foundation
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - gmail_cleanup/__init__.py
  - gmail_cleanup/auth.py
  - gmail_cleanup/gmail_client.py
  - gmail_cleanup/cleaner.py
  - gmail_cleanup/main.py
autonomous: true
requirements:
  - AUTH-02
  - AUTH-03

must_haves:
  truths:
    - "auth.py uses scope https://mail.google.com/ (not gmail.modify)"
    - "First run triggers browser OAuth prompt; token saved to ~/.config/gmail-clean/token.json"
    - "Second run completes silently by loading token from ~/.config/gmail-clean/token.json"
    - "uv run gmail-clean lists one Gmail message ID, confirming the API connection works"
  artifacts:
    - path: "gmail_cleanup/auth.py"
      provides: "get_credentials() and build_gmail_service() functions"
      contains: "https://mail.google.com/"
    - path: "gmail_cleanup/main.py"
      provides: "Typer entry point that authenticates and verifies API connection"
      contains: "build_gmail_service"
    - path: "gmail_cleanup/__init__.py"
      provides: "Package marker"
    - path: "gmail_cleanup/gmail_client.py"
      provides: "Stub for Phase 2 gmail operations"
    - path: "gmail_cleanup/cleaner.py"
      provides: "Stub for Phase 4 deletion logic"
  key_links:
    - from: "gmail_cleanup/auth.py"
      to: "~/.config/gmail-clean/token.json"
      via: "TOKEN_PATH.write_text(creds.to_json())"
      pattern: "TOKEN_PATH\\.write_text"
    - from: "gmail_cleanup/auth.py"
      to: "credentials.json"
      via: "Path(__file__).parent.parent / 'credentials.json'"
      pattern: "__file__.*parent.*parent.*credentials"
    - from: "gmail_cleanup/main.py"
      to: "gmail_cleanup/auth.py"
      via: "from gmail_cleanup.auth import build_gmail_service"
      pattern: "from gmail_cleanup\\.auth import"
---

<objective>
Create the Python package with a working auth module that implements the full OAuth token-caching flow and verifies the Gmail API connection.

Purpose: auth.py is the security-critical foundation all downstream phases import. It must use the correct scope and the correct token/credential paths so the API connection works from day one.
Output: gmail_cleanup/ package with auth.py, main.py (smoke-test entry point), and stub modules for future phases.
</objective>

<execution_context>
@/Users/dalwrigh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dalwrigh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create package and auth module</name>
  <files>
    gmail_cleanup/__init__.py
    gmail_cleanup/auth.py
    gmail_cleanup/gmail_client.py
    gmail_cleanup/cleaner.py
  </files>
  <action>
    Create the gmail_cleanup/ directory and all four files.

    **gmail_cleanup/__init__.py** — empty file (just a package marker):
    ```python
    # gmail_cleanup package
    ```

    **gmail_cleanup/auth.py** — full OAuth implementation:
    ```python
    """Gmail OAuth authentication with token caching."""

    from pathlib import Path

    from google.auth.transport.requests import Request
    from google.oauth2.credentials import Credentials
    from google_auth_oauthlib.flow import InstalledAppFlow
    from googleapiclient.discovery import build

    # https://mail.google.com/ is required for batchDelete.
    # Do NOT use gmail.modify — it returns HTTP 403 on batchDelete.
    # Source: googleapis/google-api-python-client#2710
    SCOPES = ["https://mail.google.com/"]

    # Token stored in XDG config dir — works regardless of invocation directory.
    # Do NOT use a CWD-relative path; this tool is invoked from many directories.
    TOKEN_PATH = Path.home() / ".config" / "gmail-clean" / "token.json"

    # credentials.json lives at the project root, one level above this package file.
    # auth.py is at: <root>/gmail_cleanup/auth.py
    # credentials.json is at: <root>/credentials.json
    # Do NOT use os.getcwd() — it breaks when tool is invoked from another directory.
    CREDENTIALS_PATH = Path(__file__).parent.parent / "credentials.json"


    def get_credentials() -> Credentials:
        """Load cached credentials or trigger OAuth browser flow.

        First run: opens browser, user grants consent, token saved to TOKEN_PATH.
        Subsequent runs: loads token from TOKEN_PATH, refreshes silently if expired.

        NOTE: If SCOPES is ever changed, delete TOKEN_PATH and re-authenticate.
        The cached token scope is not re-validated at load time.
        """
        creds = None

        if TOKEN_PATH.exists():
            creds = Credentials.from_authorized_user_file(str(TOKEN_PATH), SCOPES)

        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                # Silent refresh — no browser needed
                creds.refresh(Request())
            else:
                # First run: open browser for user consent
                print("Opening browser for Gmail authentication...")
                print("If the browser does not open automatically, visit the URL shown below.")
                flow = InstalledAppFlow.from_client_secrets_file(
                    str(CREDENTIALS_PATH), SCOPES
                )
                creds = flow.run_local_server(
                    port=0,
                    open_browser=True,
                    authorization_prompt_message="",  # suppress duplicate URL print
                    success_message="Authentication complete. You can close this tab.",
                )
                print("Authentication successful.")

            # Persist token for next run.
            # Create directory first — ~/.config/gmail-clean/ may not exist.
            TOKEN_PATH.parent.mkdir(parents=True, exist_ok=True)
            TOKEN_PATH.write_text(creds.to_json())

        return creds


    def build_gmail_service():
        """Return authenticated Gmail API service object."""
        return build("gmail", "v1", credentials=get_credentials())
    ```

    **gmail_cleanup/gmail_client.py** — stub for Phase 2:
    ```python
    """Gmail API operations — implemented in Phase 2 and Phase 3."""


    def list_messages(service, query: str, max_results: int = 500) -> list[dict]:
        """Return list of message dicts matching query. Stub — Phase 3."""
        raise NotImplementedError("Implemented in Phase 3")
    ```

    **gmail_cleanup/cleaner.py** — stub for Phase 4:
    ```python
    """Email deletion logic — implemented in Phase 4."""


    def batch_delete(service, message_ids: list[str]) -> int:
        """Permanently delete messages by ID. Stub — Phase 4."""
        raise NotImplementedError("Implemented in Phase 4")
    ```
  </action>
  <verify>
    Run: uv run python -c "from gmail_cleanup.auth import SCOPES, TOKEN_PATH, CREDENTIALS_PATH, get_credentials, build_gmail_service; print('SCOPES:', SCOPES)"
    Expected: SCOPES: ['https://mail.google.com/']

    Run: uv run python -c "from gmail_cleanup.auth import TOKEN_PATH; import pathlib; expected = pathlib.Path.home() / '.config' / 'gmail-clean' / 'token.json'; assert TOKEN_PATH == expected, f'Wrong path: {TOKEN_PATH}'; print('TOKEN_PATH OK')"
    Expected: TOKEN_PATH OK
  </verify>
  <done>
    gmail_cleanup/__init__.py, auth.py, gmail_client.py, and cleaner.py all exist. auth.py imports cleanly with correct SCOPES and TOKEN_PATH values. Stubs raise NotImplementedError with phase context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create main.py entry point with connection smoke test</name>
  <files>gmail_cleanup/main.py</files>
  <action>
    Create gmail_cleanup/main.py as a minimal Typer app. In Phase 1, the only command is a connection verification that confirms OAuth works and can reach the Gmail API.

    ```python
    """Gmail Cleanup CLI — Phase 1 entry point (auth verification only)."""

    import typer
    from googleapiclient.errors import HttpError

    from gmail_cleanup.auth import build_gmail_service

    app = typer.Typer(
        name="gmail-clean",
        help="Delete old Gmail messages from the command line.",
        add_completion=False,
    )


    @app.command()
    def main() -> None:
        """Verify Gmail authentication and API connection."""
        try:
            service = build_gmail_service()
        except FileNotFoundError as exc:
            typer.echo(f"Error: credentials.json not found — {exc}", err=True)
            raise typer.Exit(code=1)

        # Verify connection by fetching user profile (read-only, no messages accessed)
        try:
            profile = service.users().getProfile(userId="me").execute()
            email = profile["emailAddress"]
            typer.echo(f"Connected to Gmail as: {email}")
        except HttpError as exc:
            typer.echo(f"Gmail API error: {exc}", err=True)
            raise typer.Exit(code=1)

        # Verify list access by fetching one message ID (proves the scope works)
        try:
            result = service.users().messages().list(userId="me", maxResults=1).execute()
            messages = result.get("messages", [])
            if messages:
                typer.echo(f"API access confirmed. First message ID: {messages[0]['id']}")
            else:
                typer.echo("API access confirmed (no messages in mailbox).")
        except HttpError as exc:
            typer.echo(f"Gmail list error: {exc}", err=True)
            raise typer.Exit(code=1)


    if __name__ == "__main__":
        app()
    ```

    After writing the file, install the package in editable mode so the `gmail-clean` script works:
    ```bash
    uv sync
    ```
    (uv re-runs sync to pick up the new package source now that gmail_cleanup/ exists)
  </action>
  <verify>
    Run: uv run python -c "from gmail_cleanup.main import app; print('main.py imports OK')"
    Expected: prints "main.py imports OK" with no ImportError.

    Run: uv run gmail-clean --help
    Expected: shows help text including "Verify Gmail authentication and API connection."
  </verify>
  <done>
    gmail_cleanup/main.py exists with Typer app and main() command. `uv run gmail-clean --help` shows help without error. The entry point is wired correctly in pyproject.toml and the package installs cleanly.
  </done>
</task>

</tasks>

<verification>
Run all three checks:
1. uv run python -c "from gmail_cleanup.auth import SCOPES; assert SCOPES == ['https://mail.google.com/'], f'Wrong scope: {SCOPES}'; print('Scope OK')"
2. uv run gmail-clean --help — must show help text without ImportError
3. grep -r "gmail.modify" gmail_cleanup/ — must return NO results (wrong scope must not appear anywhere)
</verification>

<success_criteria>
- All five files in gmail_cleanup/ exist and are syntactically valid Python
- SCOPES is ["https://mail.google.com/"] — confirmed by import check
- TOKEN_PATH resolves to ~/.config/gmail-clean/token.json — confirmed by assertion
- CREDENTIALS_PATH resolves to Path(__file__).parent.parent / "credentials.json"
- `uv run gmail-clean --help` works without error
- No reference to "gmail.modify" anywhere in the package
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
