---
phase: 01-foundation
plan: "03"
type: execute
wave: 3
depends_on:
  - "01-02"
files_modified: []
autonomous: false
requirements:
  - AUTH-02

must_haves:
  truths:
    - "First run opens browser OAuth prompt and saves token to ~/.config/gmail-clean/token.json"
    - "Second run completes silently (no browser prompt) using cached token"
    - "The authenticated service lists at least the user email address, confirming API access"
  artifacts:
    - path: "~/.config/gmail-clean/token.json"
      provides: "Cached OAuth token for silent subsequent runs"
  key_links:
    - from: "gmail-clean command"
      to: "~/.config/gmail-clean/token.json"
      via: "TOKEN_PATH.write_text(creds.to_json()) on first run"
      pattern: "token\\.json"
---

<objective>
Human-verified OAuth round-trip: confirm first-run browser prompt, token caching, and silent second-run behavior work correctly against the real Gmail API.

Purpose: Code correctness (PLAN 02) can be validated statically, but OAuth browser flow and real API connectivity require a human to run the tool. This checkpoint closes the loop.
Output: Verified token at ~/.config/gmail-clean/token.json; confirmed API access.
</objective>

<execution_context>
@/Users/dalwrigh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dalwrigh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prepare for OAuth verification</name>
  <files></files>
  <action>
    Before asking the user to run the OAuth flow, ensure the environment is clean:

    1. Check if token.json already exists from a previous test run:
       ```bash
       ls ~/.config/gmail-clean/token.json 2>/dev/null && echo "EXISTS" || echo "NOT FOUND"
       ```

    2. If token.json EXISTS, delete it so the first-run browser flow is triggered:
       ```bash
       rm ~/.config/gmail-clean/token.json
       ```
       This ensures the user sees the actual first-run behavior, not a cached token from a prior test.

    3. Confirm credentials.json is present in the project root (required for InstalledAppFlow):
       ```bash
       ls -la credentials.json
       ```
       If missing, the OAuth flow cannot proceed. Report to user.

    4. Confirm the tool is ready:
       ```bash
       uv run gmail-clean --help
       ```
       Must succeed. If it fails, do not proceed to the checkpoint — fix the error first.

    Print: "Ready for OAuth verification. Proceeding to human checkpoint."
  </action>
  <verify>
    - credentials.json exists in project root
    - ~/.config/gmail-clean/token.json does NOT exist (deleted if it was there)
    - uv run gmail-clean --help exits 0
  </verify>
  <done>
    Environment is clean and ready for live OAuth test: no cached token, credentials present, CLI entry point functional.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify OAuth browser flow and token caching</name>
  <files></files>
  <action>Human verifies OAuth browser flow, token persistence, and silent second-run behavior by running `uv run gmail-clean` twice per the instructions below.</action>
  <verify>User confirms: first run opened browser, token saved, second run silent, email address displayed, git status clean.</verify>
  <done>User types "approved" after confirming all steps succeeded.</done>
  <what-built>
    Full Gmail OAuth flow:
    - auth.py with token-caching InstalledAppFlow
    - main.py entry point that authenticates and verifies API connection
    - Token stored at ~/.config/gmail-clean/token.json
  </what-built>
  <how-to-verify>
    Before the GCP consent screen step: verify your GCP OAuth consent screen is set to "Internal" or "Production" — NOT "Testing". Testing mode tokens expire silently after 7 days. If it is "Testing", change it in GCP Console -> APIs and Services -> OAuth consent screen before proceeding.

    **First run (browser flow):**
    1. Run: uv run gmail-clean
    2. Expected: Terminal prints "Opening browser for Gmail authentication..."
    3. Expected: Browser opens automatically to Google sign-in page
    4. Sign in and grant the requested permissions
    5. Expected: Browser shows "Authentication complete. You can close this tab."
    6. Expected: Terminal prints "Authentication successful." then "Connected to Gmail as: your@email.com"
    7. Expected: Terminal prints "API access confirmed. First message ID: ..." (or "no messages" if inbox is empty)

    **Token file check:**
    8. Run: ls -la ~/.config/gmail-clean/token.json
    9. Expected: File exists with recent timestamp

    **Second run (silent):**
    10. Run: uv run gmail-clean
    11. Expected: No browser opens, no "Opening browser..." message
    12. Expected: Prints "Connected to Gmail as: your@email.com" immediately
    13. Expected: Prints "API access confirmed." line

    **Security check:**
    14. Run: git status
    15. Expected: credentials.json, client_id, client_secret NOT in output anywhere
  </how-to-verify>
  <resume-signal>Type "approved" if all steps succeeded, or describe what went wrong so it can be fixed.</resume-signal>
</task>

</tasks>

<verification>
All verified interactively above. The phase is complete when:
1. First run produced a browser OAuth prompt
2. Token was saved to ~/.config/gmail-clean/token.json
3. Second run completed without opening a browser
4. Connected email address was displayed on both runs
5. git status shows no credential files
</verification>

<success_criteria>
- OAuth browser flow completes on first run (user sees and approves consent screen)
- token.json exists at ~/.config/gmail-clean/token.json after first run
- Second run is silent (no browser, no prompts)
- gmail-clean outputs connected email address and a message ID (or "no messages")
- git status is clean of all credential file names
- Phase 1 success criteria all confirmed: authentication works, credentials protected, API accessible
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
